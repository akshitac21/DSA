# DSA Mastery Roadmap 

A structured, problem-driven plan to master Data Structures & Algorithms for interviews, contests, and real problem-solving.

> Rule of thumb:  
> **Consistency > Speed**  
> 1–3 problems daily beats weekend heroics.

---

## Phase 0: Absolute Foundations (Week 1)

### Time & Space Complexity
- Big-O, Big-Ω, Big-Θ
- Best / Average / Worst case
- Space complexity basics
- Amortized analysis (basic intuition)

Goal: Look at code and *instantly* estimate complexity.

---

## Phase 1: Core Data Structures (Month 1–2)

### Arrays
- Basics & operations
- Prefix sums
- Sliding window (fixed + variable)
- Two pointers (intro)
- Kadane’s Algorithm

### Hash Tables
- HashMap vs HashSet
- Frequency counting
- Subarray sum problems
- Two-sum patterns
- Collision intuition (not implementation hell)

### Linked Lists
- Singly & doubly linked lists
- Fast & slow pointers
- Reverse linked list (iterative + recursive)
- Cycle detection
- Merge two sorted lists

### Stacks & Queues
- Stack operations
- Queue & deque
- Monotonic stack
- Next greater element
- Valid parentheses

Practice Focus:
- Arrays + HashMaps = 40% of interview problems  
- Solve **at least 80–100 problems** in this phase

---

## Phase 2: Core Techniques (Month 3)

### Recursion & Backtracking
- Base cases & recursion trees
- Subsets
- Permutations
- Combination sum
- N-Queens
- Backtracking vs brute force

---

### Searching Algorithms
- Linear search
- Binary search
- Binary search on answer
- Lower/upper bound patterns

---

### Sorting Algorithms
- Bubble, Selection, Insertion (learn, don’t worship)
- Merge Sort
- Quick Sort
- Stability & in-place sorting
- When to use which sort

---

### Bit Manipulation
- Bitwise operators
- XOR tricks
- Set / unset / toggle bits
- Power of two problems
- Subset generation using bits

---

## Phase 3: Advanced Data Structures (Month 4–5)

### Trees
- Binary tree basics
- DFS (pre, in, post)
- BFS (level order)
- Height & depth
- Diameter of tree
- Path sum problems

---

### Binary Search Trees (BST)
- BST properties
- Insert, delete, search
- Validate BST
- Range queries
- Lowest Common Ancestor

---

### Heaps (Priority Queues)
- Min heap & max heap
- Heap operations
- Top-K elements
- Kth largest/smallest
- Heap vs sorting

---

### Tries
- Prefix trees
- Insert / search / delete
- Word search
- Autocomplete logic

---

## Phase 4: Graphs & Union-Find (Month 6)

### Graph Fundamentals
- Adjacency list vs matrix
- BFS & DFS
- Connected components
- Cycle detection

### Graph Algorithms
- Dijkstra’s Algorithm
- Bellman-Ford
- Floyd-Warshall
- Topological Sort
- Kosaraju’s Algorithm (SCC)

### Minimum Spanning Tree
- Prim’s Algorithm
- Kruskal’s Algorithm

### Union-Find (DSU)
- Normal DSU
- Union by rank
- Path compression

---

## Phase 5: Dynamic Programming (Month 6–7)

### DP Foundations
- Recursion → Memoization → Tabulation
- State definition
- Transition logic

### Classic DP Problems
- Fibonacci
- Climbing stairs
- Knapsack (0/1, unbounded)
- LIS
- LCS
- Matrix DP
- DP on grids
- DP on trees (intro)

---

## Phase 6: Extra Edge Topics

### Number Theory
- GCD / LCM
- Sieve of Eratosthenes
- Modular arithmetic
- Fast exponentiation

### Greedy Algorithms
- Activity selection
- Interval scheduling
- Huffman encoding
- Greedy vs DP intuition

### OOPs (Interview Perspective)
- SOLID principles
- Inheritance vs composition
- Common design patterns (high level)
